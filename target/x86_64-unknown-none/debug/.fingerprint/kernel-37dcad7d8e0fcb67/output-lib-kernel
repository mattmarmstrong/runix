{"message":"unused import: `interrupt_with_error_code`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"kernel/src/interrupts/handlers.rs","byte_start":86,"byte_end":111,"line_start":6,"line_end":6,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"    interrupt_with_error_code,","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"kernel/src/interrupts/handlers.rs","byte_start":80,"byte_end":111,"line_start":5,"line_end":6,"column_start":14,"column_end":30,"is_primary":true,"text":[{"text":"    interrupt,","highlight_start":14,"highlight_end":15},{"text":"    interrupt_with_error_code,","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `interrupt_with_error_code`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/handlers.rs:6:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    interrupt_with_error_code,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused imports: `TSS`, `tss::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":277,"byte_end":283,"line_start":15,"line_end":15,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    tss::*,","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"kernel/src/interrupts/mod.rs","byte_start":289,"byte_end":292,"line_start":16,"line_end":16,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    TSS,","highlight_start":5,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":246,"byte_end":296,"line_start":14,"line_end":17,"column_start":1,"column_end":3,"is_primary":true,"text":[{"text":"use crate::segmentation::{","highlight_start":1,"highlight_end":27},{"text":"    tss::*,","highlight_start":1,"highlight_end":12},{"text":"    TSS,","highlight_start":1,"highlight_end":9},{"text":"};","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `TSS`, `tss::*`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/mod.rs:15:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    tss::*,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TSS,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\n"}
{"message":"formatting may not be suitable for sub-register argument","code":{"code":"asm_sub_register","explanation":null},"level":"warning","spans":[{"file_name":"kernel/src/segmentation/asm.rs","byte_start":697,"byte_end":710,"line_start":24,"line_end":24,"column_start":38,"column_end":51,"is_primary":false,"text":[{"text":"        asm!(\"mov {0}, cs\", out(reg) segment_value, options(nomem, nostack, preserves_flags));","highlight_start":38,"highlight_end":51}],"label":"for this argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"kernel/src/segmentation/asm.rs","byte_start":678,"byte_end":681,"line_start":24,"line_end":24,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"        asm!(\"mov {0}, cs\", out(reg) segment_value, options(nomem, nostack, preserves_flags));","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `{0:x}` to have the register formatted as `ax`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"or use `{0:r}` to keep the default formatting of `rax`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(asm_sub_register)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: formatting may not be suitable for sub-register argument\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/segmentation/asm.rs:24:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        asm!(\"mov {0}, cs\", out(reg) segment_value, options(nomem, nostack, preserves_flags));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfor this argument\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `{0:x}` to have the register formatted as `ax`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: or use `{0:r}` to keep the default formatting of `rax`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(asm_sub_register)]` on by default\u001b[0m\n\n"}
{"message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned references to a field of a [packed] struct got created.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1182,"byte_end":1190,"line_start":56,"line_end":56,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":13,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1071,"byte_end":1241,"line_start":54,"line_end":57,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"        f.write_fmt(format_args!(","highlight_start":21,"highlight_end":34},{"text":"            \"RIP: 0x{:x}\\t CS: 0x{:x} \\t RFLAGS: 0x{:x}\\n RSP: 0x{:x}\\t SS: 0x{:x}\",","highlight_start":1,"highlight_end":85},{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":1,"highlight_end":62},{"text":"        ))","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"format_args!","def_site_span":{"file_name":"/Users/matthewarmstrong/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":30045,"byte_end":30069,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/mod.rs:56:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.rip, self.cs, self.rflags, self.rsp, self.ss\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned references to a field of a [packed] struct got created.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1192,"byte_end":1199,"line_start":56,"line_end":56,"column_start":23,"column_end":30,"is_primary":true,"text":[{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":23,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1071,"byte_end":1241,"line_start":54,"line_end":57,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"        f.write_fmt(format_args!(","highlight_start":21,"highlight_end":34},{"text":"            \"RIP: 0x{:x}\\t CS: 0x{:x} \\t RFLAGS: 0x{:x}\\n RSP: 0x{:x}\\t SS: 0x{:x}\",","highlight_start":1,"highlight_end":85},{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":1,"highlight_end":62},{"text":"        ))","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"format_args!","def_site_span":{"file_name":"/Users/matthewarmstrong/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":30045,"byte_end":30069,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/mod.rs:56:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.rip, self.cs, self.rflags, self.rsp, self.ss\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned references to a field of a [packed] struct got created.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1201,"byte_end":1212,"line_start":56,"line_end":56,"column_start":32,"column_end":43,"is_primary":true,"text":[{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":32,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1071,"byte_end":1241,"line_start":54,"line_end":57,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"        f.write_fmt(format_args!(","highlight_start":21,"highlight_end":34},{"text":"            \"RIP: 0x{:x}\\t CS: 0x{:x} \\t RFLAGS: 0x{:x}\\n RSP: 0x{:x}\\t SS: 0x{:x}\",","highlight_start":1,"highlight_end":85},{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":1,"highlight_end":62},{"text":"        ))","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"format_args!","def_site_span":{"file_name":"/Users/matthewarmstrong/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":30045,"byte_end":30069,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/mod.rs:56:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.rip, self.cs, self.rflags, self.rsp, self.ss\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned references to a field of a [packed] struct got created.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1214,"byte_end":1222,"line_start":56,"line_end":56,"column_start":45,"column_end":53,"is_primary":true,"text":[{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":45,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1071,"byte_end":1241,"line_start":54,"line_end":57,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"        f.write_fmt(format_args!(","highlight_start":21,"highlight_end":34},{"text":"            \"RIP: 0x{:x}\\t CS: 0x{:x} \\t RFLAGS: 0x{:x}\\n RSP: 0x{:x}\\t SS: 0x{:x}\",","highlight_start":1,"highlight_end":85},{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":1,"highlight_end":62},{"text":"        ))","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"format_args!","def_site_span":{"file_name":"/Users/matthewarmstrong/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":30045,"byte_end":30069,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/mod.rs:56:45\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.rip, self.cs, self.rflags, self.rsp, self.ss\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned references to a field of a [packed] struct got created.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1224,"byte_end":1231,"line_start":56,"line_end":56,"column_start":55,"column_end":62,"is_primary":true,"text":[{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":55,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"kernel/src/interrupts/mod.rs","byte_start":1071,"byte_end":1241,"line_start":54,"line_end":57,"column_start":21,"column_end":10,"is_primary":false,"text":[{"text":"        f.write_fmt(format_args!(","highlight_start":21,"highlight_end":34},{"text":"            \"RIP: 0x{:x}\\t CS: 0x{:x} \\t RFLAGS: 0x{:x}\\n RSP: 0x{:x}\\t SS: 0x{:x}\",","highlight_start":1,"highlight_end":85},{"text":"            self.rip, self.cs, self.rflags, self.rsp, self.ss","highlight_start":1,"highlight_end":62},{"text":"        ))","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"format_args!","def_site_span":{"file_name":"/Users/matthewarmstrong/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":30045,"byte_end":30069,"line_start":876,"line_end":876,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mkernel/src/interrupts/mod.rs:56:55\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.rip, self.cs, self.rflags, self.rsp, self.ss\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 5 previous errors; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 5 previous errors; 3 warnings emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0793`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0793`.\u001b[0m\n"}
